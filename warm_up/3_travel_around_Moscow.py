# Мэрия Москвы основательно подготовилась к празднованию тысячелетия города в 2147 году,
# построив под столицей бесконечную асфальтированную площадку,
# чтобы заменить все существующие в городе автомобильные дороги.
# В память о кольцевых и радиальных дорогах разрешили двигаться по площадке только двумя способами:
#
# В сторону точки начала координат или от неё. При этом из точки начала координат
# разрешено двигаться в любом направлении.
# Вдоль окружности с центром в начале координат и радиусом, который равен текущему
# расстоянию до начала координат. Двигаться вдоль такой окружности разрешается в любом
# направлении (по или против часовой стрелки).
# Вам, как ведущему программисту ответственной инстанции поручено разработать модуль,
# который будет определять кратчайший путь из точки A, с координатами (xA, yA) в точку B
# с координатами (xB, yB). Считайте, что менять направление движения можно произвольное количество раз,
# но оно должно всегда соответствовать одному из двух описанных выше вариантов.
#
# Формат ввода
# В первой строке ввода заданы четыре целых числа xA, yA, xB и yB, по модулю не превосходящие 106.
#
# Формат вывода
# Выведите одно число — минимальное расстояние, которое придётся преодолеть по пути из точки A в точку B,
# если не нарушать правил дорожного движения. Ваш ответ будет принят, если его абсолютная или
# относительная погрешность не превосходит 10-6.

from math import atan2

x_a, y_a, x_b, y_b = map(int, input().split())
a_len = (x_a**2 + y_a**2)**0.5
b_len = (x_b**2 + y_b**2)**0.5
simple_path_len = a_len + b_len

hard_path_len = 0

if a_len > b_len:
    hard_path_len += a_len - b_len
    hard_path_len += abs(b_len * (atan2(y_a, x_a) - atan2(y_b, x_b)))
else:
    hard_path_len += b_len - a_len
    hard_path_len += abs(a_len * (atan2(y_a, x_a) - atan2(y_b, x_b)))

print(min(simple_path_len, hard_path_len))
