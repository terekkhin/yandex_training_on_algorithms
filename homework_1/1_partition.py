# Базовым алгоритмом для быстрой сортировки является алгоритм partition,
# который разбивает набор элементов на две части относительно заданного предиката.
# По сути элементы массива просто меняются местами так, что левее некоторой точки
# в нем после этой операции лежат элементы, удовлетворяющие заданному предикату, а справа — не удовлетворяющие ему.
# Например, при сортировке можно использовать предикат «меньше опорного»,
# что при оптимальном выборе опорного элемента может разбить массив на две примерно равные части.
#
# Напишите алгоритм partition в качестве первого шага для написания быстрой сортировки.
#
# Формат ввода
# В первой строке входного файла содержится число N — количество элементов массива (0 ≤ N ≤ 10**6).
# Во второй строке содержатся N целых чисел ai, разделенных пробелами (-10**9 ≤ ai ≤ 10**9).
# В третьей строке содержится опорный элемент x (-10**9 ≤ x ≤ 10**9).
# Заметьте, что x не обязательно встречается среди a_i.
#
# Формат вывода
# Выведите результат работы вашего алгоритма при использовании предиката «меньше x»:
# в первой строке выведите число элементов массива, меньших x, а во второй — количество всех остальных.

def partition(array, x, left, right):
    e, g, n = left, left, left
    for i in range(left, right):
        if array[i] < x:
            array[e], array[n] = array[n], array[e]
            if e != g:
                array[g], array[n] = array[n], array[g]
            e += 1
            g += 1
            n += 1
        elif array[i] == x:
            array[g], array[n] = array[n], array[g]
            g += 1
            n += 1
        else:
            n += 1
    return e


n = int(input())
array = list(map(int, input().split()))
x = int(input())
pointer = partition(array, x, 0, n)
print(pointer, n - pointer, sep="\n")
